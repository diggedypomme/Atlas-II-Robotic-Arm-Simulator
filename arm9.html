<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot Arm Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
    }
    .command-button {
      display: inline-block;
      margin: 2px;
      padding: 5px 10px;
      background-color: #ccc;
      border: none;
      cursor: pointer;
      border-radius: 3px;
    }
    .command-button:hover {
      background-color: #bbb;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="text" id="commandInput" placeholder="Enter command">
    <button onclick="executeCommand()">OK</button>
    <br>
    <button class="command-button" onclick="fillAndSubmit('A1')">A1</button>
    <button class="command-button" onclick="fillAndSubmit('A10')">A10</button>
    <button class="command-button" onclick="fillAndSubmit('B0')">B0</button>
    <button class="command-button" onclick="fillAndSubmit('B10')">B10</button>
    <button class="command-button" onclick="fillAndSubmit('C1')">C1</button>
    <button class="command-button" onclick="fillAndSubmit('C10')">C10</button>
    <button class="command-button" onclick="fillAndSubmit('D5')">D5</button>
    <button class="command-button" onclick="fillAndSubmit('D10')">D10</button>
    <button class="command-button" onclick="fillAndSubmit('E1')">E1</button>
    <button class="command-button" onclick="fillAndSubmit('E10')">E10</button>
    <button class="command-button" onclick="fillAndSubmit('F1')">F1</button>
    <button class="command-button" onclick="fillAndSubmit('F10')">F10</button>
    <button class="command-button" onclick="fillAndSubmit('G0')">G0</button>
    <button class="command-button" onclick="fillAndSubmit('G1.5')">G1.5</button>
    <button class="command-button" onclick="fillAndSubmit('H0')">H0</button>
    <button class="command-button" onclick="fillAndSubmit('H1.5')">H1.5</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 30);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Gradient background
    const gradientCanvas = document.createElement('canvas');
    gradientCanvas.width = 32;
    gradientCanvas.height = window.innerHeight;
    const gradientContext = gradientCanvas.getContext('2d');
    const gradient = gradientContext.createLinearGradient(0, 0, 0, gradientCanvas.height);
    gradient.addColorStop(0, '#0000ff'); // Blue
    gradient.addColorStop(1, '#ff00ff'); // Purple
    gradientContext.fillStyle = gradient;
    gradientContext.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
    const gradientTexture = new THREE.CanvasTexture(gradientCanvas);
    scene.background = gradientTexture;

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5).normalize();
    scene.add(directionalLight);

    // GLTF Loader
    const loader = new THREE.GLTFLoader();
    let base, neck, head, arm, wrist, hand, fingerL, fingerR;

    // Helper function to create pivot point markers
    function createPivotPointMarker() {
      const geometry = new THREE.SphereGeometry(0.02); // Adjust size as needed
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color for visibility
      return new THREE.Mesh(geometry, material);
    }

    // Function to adjust pivot point of an object
    function adjustPivotPoint(object, newPivot) {
      if (object && object.geometry) {
        if (object.geometry.vertices !== undefined) {
          object.geometry.computeBoundingBox();
          const currentPivot = new THREE.Vector3();
          object.geometry.boundingBox.getCenter(currentPivot);

          const offset = currentPivot.clone().sub(newPivot);
          object.geometry.translate(offset.x, offset.y, offset.z);
          object.position.add(offset);
        } else {
          console.error('Geometry vertices are undefined or not yet loaded.');
        }
      } else {
        console.error('Object or its geometry is undefined or not yet loaded.');
      }
    }

    // Load and position GLTF models
    loader.load('arm3_table.glb', function(gltf) {
      base = gltf.scene;
      base.position.set(0, 0, 0);
      scene.add(base);

      loader.load('arm3_base.glb', function(gltf) {
        neck = gltf.scene;
        neck.position.set(0, 0, 0);  // Adjust based on your model
        base.add(neck);

        loader.load('arm3_neck.glb', function(gltf) {
          neck = gltf.scene;
          neck.position.set(0, 0, 0);  // Adjust based on your model
          base.add(neck);

          loader.load('arm3_head.glb', function(gltf) {
            head = gltf.scene;
            head.position.set(0, 0, 0);  // Adjust based on your model
            neck.add(head);

            // Example: Adjust pivot point and display marker for head
            adjustPivotPoint(head, new THREE.Vector3(0, 10, 0));
            const headPivotMarker = createPivotPointMarker();
            headPivotMarker.position.copy(head.position);
            scene.add(headPivotMarker);

            loader.load('arm3_arm.glb', function(gltf) {
              arm = gltf.scene;
              arm.position.set(0, 0, 0);  // Adjust based on your model
              head.add(arm);

              loader.load('arm3_wrist.glb', function(gltf) {
                wrist = gltf.scene;
                wrist.position.set(0, 0, 0);  // Adjust based on your model
                arm.add(wrist);

                loader.load('arm3_hand.glb', function(gltf) {
                  hand = gltf.scene;
                  hand.position.set(0, 0, 0);  // Adjust based on your model
                  wrist.add(hand);

                  // Example: Adjust pivot point and display marker for hand
                  adjustPivotPoint(hand, new THREE.Vector3(0, 5, 0));
                  const handPivotMarker = createPivotPointMarker();
                  handPivotMarker.position.copy(hand.position);
                  scene.add(handPivotMarker);

                  loader.load('arm3_finger_l.glb', function(gltf) {
                    fingerL = gltf.scene;
                    fingerL.position.set(0, 0, 0);  // Adjust based on your model
                    hand.add(fingerL);

                    loader.load('arm3_finger_r.glb', function(gltf) {
                      fingerR = gltf.scene;
                      fingerR.position.set(0, 0, 0);  // Adjust based on your model
                      hand.add(fingerR);

                      // Example: Adjust pivot point and display marker for fingerR
                      adjustPivotPoint(fingerR, new THREE.Vector3(0, 0, 0));
                      const fingerRPivotMarker = createPivotPointMarker();
                      fingerRPivotMarker.position.copy(fingerR.position);
                      scene.add(fingerRPivotMarker);

                      // Set initial camera position after loading
                      camera.position.set(1.7, 1.7, 1.7);

                      // Start animation loop
                      animate();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    // Animation function
    let targetBaseRotationZ = 0;
    let targetNeckRotation = 0;
    let targetHeadRotationX = 0;
    let targetArmTranslationY = 0;
    let targetWristRotationX = 0;
    let targetHandRotationZ = 0;
    let targetFingerLTranslationX = 0;
    let targetFingerRTranslationX = 0;

    const rotationSpeed = 0.01; // Adjust speed as needed
    const translationSpeed = 0.001; // Adjust speed as needed

    function animate() {
      requestAnimationFrame(animate);

      // Update rotations and translations
      if (base) base.rotation.z = updateRotation(base.rotation.z, targetBaseRotationZ);
      if (neck) neck.rotation.y = updateRotation(neck.rotation.y, targetNeckRotation);
      if (head) head.rotation.x = updateRotation(head.rotation.x, targetHeadRotationX);
      if (arm) arm.position.z = updateTranslation(arm.position.z, targetArmTranslationY);
      if (wrist) wrist.rotation.x = updateRotation(wrist.rotation.x, targetWristRotationX);
      if (hand) hand.rotation.z = updateRotation(hand.rotation.z, targetHandRotationZ);
      if (fingerL) fingerL.position.x = updateTranslation(fingerL.position.x, targetFingerLTranslationX);
      if (fingerR) fingerR.position.x = updateTranslation(fingerR.position.x, targetFingerRTranslationX);

      controls.update();
      renderer.render(scene, camera);
    }

    // Helper functions for smooth motion
    function updateRotation(currentRotation, targetRotation) {
      if (Math.abs(targetRotation - currentRotation) < rotationSpeed) {
        return targetRotation;
      }
      return currentRotation + Math.sign(targetRotation - currentRotation) * rotationSpeed;
    }

    function updateTranslation(currentPosition, targetPosition) {
      if (Math.abs(targetPosition - currentPosition) < translationSpeed) {
        return targetPosition;
      }
      return currentPosition + Math.sign(targetPosition - currentPosition) * translationSpeed;
    }

    // Execute command based on input
    function executeCommand() {
      const command = document.getElementById('commandInput').value.trim().toUpperCase();
      const joint = command.charAt(0);
      const value = parseFloat(command.slice(1));

      switch (joint) {
        case 'A':
          moveBaseRotation(value);
          break;
        case 'B':
          moveNeckRotation(value);
          break;
        case 'C':
          moveArmTranslation(value);
          break;
        case 'D':
          moveWristRotation(value);
          break;
        case 'E':
          moveHandRotation(value);
          break;
        case 'F':
          // Handle F command if needed
          break;
        case 'G':
          moveFingerLTranslation(value);
          break;
        case 'H':
          moveFingerRTranslation(value);
          break;
        default:
          alert('Invalid command');
      }
    }

    // Functions to update target values based on commands
    function moveBaseRotation(newPosition) {
      targetBaseRotationZ = newPosition * Math.PI / 180; // Convert to radians
    }

    function moveNeckRotation(newPosition) {
      targetNeckRotation = newPosition * Math.PI / 180; // Convert to radians
    }

    function moveArmTranslation(newPosition) {
      targetArmTranslationY = newPosition / 100; // Convert to units
    }

    function moveWristRotation(newPosition) {
      targetWristRotationX = newPosition * Math.PI / 180; // Convert to radians
    }

    function moveHandRotation(newPosition) {
      targetHandRotationZ = newPosition * Math.PI / 180; // Convert to radians
    }

    function moveFingerLTranslation(newPosition) {
      targetFingerLTranslationX = newPosition / 100; // Convert to units
    }

    function moveFingerRTranslation(newPosition) {
      targetFingerRTranslationX = -newPosition / 100; // Convert to units
    }

    // Fill input and execute command
    function fillAndSubmit(command) {
      document.getElementById('commandInput').value = command;
      executeCommand();
    }

    // Start animation loop
    animate();
  </script>
</body>
</html>
